# 即时通讯系统文档

## 功能概述

即时通讯（IM）系统为平台用户提供了实时沟通的能力，是促进买卖双方交流、协商和解决问题的关键功能。系统基于WebSocket实现，支持用户间一对一私聊，并为管理员提供了查看和管理所有会话的能力。

### 核心功能
- **一对一私聊**：任何两个用户之间都可以发起实时聊天。在商品详情页，买家可以方便地点击“联系卖家”直接开始对话。
- **会话列表**：用户可以在聊天中心看到自己所有的历史会话列表，按最新消息时间排序。
- **实时消息收发**：基于WebSocket，消息可以被实时推送到接收方，无需轮询。
- **历史消息加载**：进入聊天窗口时，会自动加载最近的历史消息，并支持向上滚动加载更多。
- **未读消息提示**：会话列表和全局悬浮按钮会显示未读消息数量。
- **管理员监控**：管理员拥有一个专门的后台视图，可以查看平台上的所有聊天会话，并能进入任意会话查看完整聊天记录。

## 技术选型

- **后端**: Spring Boot WebSocket + STOMP协议
  - 使用Spring框架提供的WebSocket支持，通过STOMP（Simple Text Oriented Messaging Protocol）作为应用层协议来简化消息格式和路由。
- **前端**: `stompjs/stompjs` + `sockjs-client`
  - `sockjs-client` 提供了在浏览器不支持WebSocket时的回退方案（如长轮询）。
  - `stompjs` 实现了STOMP协议，使得前端可以方便地连接、订阅和发送消息。

## 数据库表结构

### chat_message表（聊天消息表）
```sql
CREATE TABLE `chat_message` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '消息ID',
  `sender_id` int NOT NULL COMMENT '发送者ID',
  `recipient_id` int NOT NULL COMMENT '接收者ID',
  `content` text NOT NULL COMMENT '消息内容',
  `is_read` tinyint(1) DEFAULT '0' COMMENT '是否已读',
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `sender_id` (`sender_id`),
  KEY `recipient_id` (`recipient_id`),
  CONSTRAINT `chat_message_ibfk_1` FOREIGN KEY (`sender_id`) REFERENCES `user` (`id`),
  CONSTRAINT `chat_message_ibfk_2` FOREIGN KEY (`recipient_id`) REFERENCES `user` (`id`)
);
```

## 后端API与WebSocket端点

### HTTP API

#### 1. 获取历史消息
`GET /api/chat/history/{userId1}/{userId2}`
- **Authorization**: `Bearer {token}`
- **Response**: 返回两个用户之间的历史消息列表（分页）。

#### 2. 获取用户会话列表
`GET /api/chat/sessions`
- **Authorization**: `Bearer {token}`
- **Response**: 返回当前用户的会话列表，包含每个会话的最后一条消息和未读计数。

### WebSocket (STOMP) 端点

- **连接端点**: `/ws`
  - 前端通过SockJS和STOMP客户端连接到这个HTTP端点，Spring会自动将其升级为WebSocket连接。

- **消息代理 (Broker)**: `/topic`, `/user`
  - `/topic`: 用于公共广播，本系统中较少使用。
  - `/user`: 用于点对点消息。Spring会自动将发送到 `/user/{username}/queue/messages` 的消息路由给名为 `{username}` 的用户。

- **应用目标 (Application Destination)**: `/app`
  - 前端发送消息到以 `/app` 为前缀的目标，例如 `/app/chat`。这些消息会被路由到后端的 `@MessageMapping` 注解的方法进行处理。

## 前端视图与组件

- **ChatView.vue**: 聊天中心主页面。
  - 路由: `/chat`
  - 左侧是会话列表，右侧是当前选中的聊天窗口。

- **ChatWindow.vue**: 独立的聊天窗口组件。
  - 在 `ChatView.vue` 中被用作右侧的聊天面板。
  - 负责显示消息流、处理用户输入和发送消息。

- **AdminChatView.vue**: 管理员专用的聊天监控页面。
  - 路由: `/admin/chat`
  - 展示平台所有用户的会话列表，管理员可以点击进入任何一个会话进行查看。

- **FloatingChatButton.vue**: 全局悬浮聊天按钮。
  - 显示未读消息总数，并作为进入聊天中心的快捷入口。

## 消息收发流程

1.  **建立连接**: 用户登录后，前端的 `WebSocketService.js` 初始化 `StompClient`，通过 `/ws` 端点与后端建立WebSocket连接。
2.  **订阅私信队列**: 连接成功后，客户端会订阅一个属于自己的私信队列，地址通常是 `/user/queue/messages`。后端会将发给该用户的消息推送到这个地址。
3.  **用户发送消息**: 
    -   用户在 `ChatWindow.vue` 的输入框中输入内容并点击发送。
    -   前端调用 `stompClient.publish()` 方法，将消息发送到应用目标，例如 `/app/chat`。
    -   消息体 (payload) 是一个JSON字符串，包含 `{ "recipientId": 123, "content": "你好" }`。
4.  **后端处理与存储**: 
    -   `ChatController.java` 中带有 `@MessageMapping("/chat")` 注解的方法接收到这条消息。
    -   该方法从消息中解析出 `recipientId` 和 `content`。
    -   将消息对象（包含 `senderId`, `recipientId`, `content` 等）保存到 `chat_message` 数据库表中。
5.  **后端转发消息**: 
    -   `ChatController` 使用 `SimpMessagingTemplate` 将这条消息发送到接收者的私信队列中。
    -   目标地址是 `/user/{recipientUsername}/queue/messages`。Spring Security和WebSocket的集成可以确保 `{recipientUsername}` 被正确解析。
6.  **接收方接收消息**: 
    -   接收方的客户端因为已经订阅了该队列，所以会立即收到这条消息。
    -   `onMessage` 回调函数被触发，前端将新消息追加到 `ChatWindow.vue` 的消息列表中，并滚动到底部。
    -   如果接收方当前不在与发送方的聊天窗口，则更新会话列表的未读计数和 `FloatingChatButton.vue` 的角标。

## 核心实现

### 后端
- **WebSocketConfig.java**: Spring WebSocket的配置类。
  -   注册STOMP端点 (`/ws`)。
  -   配置消息代理（Message Broker），定义了 `/topic` 和 `/user` 前缀。
  -   配置应用目标前缀 (`/app`)。
- **ChatController.java**: 同时包含处理HTTP请求的 `@RestController` 方法和处理WebSocket消息的 `@MessageMapping` 方法。
- **ChatMessage.java**: 消息实体的JPA/MyBatis定义。
- **ChatService.java**: 封装了与聊天相关的业务逻辑，如获取历史消息、获取会话列表等。

### 前端
- **WebSocketService.js**: 封装了 `StompClient` 的所有操作，如连接、断开、订阅、发送消息，并提供事件回调（如 `onConnected`, `onMessageReceived`），实现与Vue组件的解耦。
- **Vuex Store (例如 `chat.js` 模块)**: 用于管理全局的未读消息总数 `unreadCount`，方便 `FloatingChatButton` 等组件共享。
- **ChatWindow.vue**: 组件内部通过 `ref` 或 `data` 维护一个 `messages` 数组。当收到新消息或加载历史消息时，更新这个数组。向上滚动时，触发加载更多历史消息的逻辑。
