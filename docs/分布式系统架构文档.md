# c2csectrade 分布式系统架构文档

## 系统概述

c2csectrade  是一个**生产级分布式二手商品交易平台**，支持多品类商品（数码产品、服装鞋包、图书、家居生活、运动户外等）的在线交易。系统采用分布式架构设计，引入了多种中间件和分布式组件，提升系统的可扩展性、可靠性和性能。

## 分布式组件架构

```
┌─────────────────────────────────────────────────────────────┐
│                        Frontend (Vue.js)                     │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                    Spring Boot Application                   │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │ Controllers  │  │  Services     │  │  Mappers     │     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
└─────────────────────────────────────────────────────────────┘
         ↓                    ↓                    ↓
┌────────────────┐  ┌────────────────┐  ┌────────────────┐
│     Redis      │  │   RabbitMQ     │  │    MySQL       │
│   (缓存/会话)   │  │  (消息队列)     │  │  (持久化)      │
└────────────────┘  └────────────────┘  └────────────────┘
         ↓                    ↓
┌────────────────┐  ┌────────────────┐
│ Elasticsearch  │  │     MinIO      │
│   (全文搜索)    │  │  (对象存储)     │
└────────────────┘  └────────────────┘
```

## 1. Redis 分布式缓存

### 1.1 应用场景

#### 用户会话管理
- **Key格式**: `spring:session:sessions:{sessionId}`
- **数据类型**: Hash
- **TTL**: 30分钟 (可续期)
- **用途**: 分布式会话，支持多实例部署

#### 推荐系统缓存
```
# 用户浏览历史
Key: history:user:{userId}
Type: Sorted Set
Score: timestamp
TTL: 永久

# 用户兴趣画像
Key: profile:user:{userId}
Type: Hash
Field: tag -> interest_score
TTL: 永久

# 协同过滤推荐
Key: recommend:item-cf:{productId}
Type: Sorted Set
Score: similarity
TTL: 永久 (每日更新)

# 内容相似度推荐
Key: recommend:content:{productId}
Type: Sorted Set
Score: similarity
TTL: 7天

# 商品热度
Key: recommend:popularity
Type: Sorted Set
Score: popularity_score
TTL: 永久 (实时更新)
```

#### 分布式锁
```java
// 防止超卖
Key: lock:product:{productId}
Type: String
Value: lockId
TTL: 10秒
```

#### 限流控制
```java
// API限流
Key: ratelimit:api:{userId}:{endpoint}
Type: String
Value: count
TTL: 1分钟
```

### 1.2 配置

```properties
# Redis配置
spring.redis.host=redis
spring.redis.port=6379
spring.redis.database=0
spring.redis.timeout=3000ms
spring.redis.lettuce.pool.max-active=8
spring.redis.lettuce.pool.max-idle=8
spring.redis.lettuce.pool.min-idle=0
```

### 1.3 性能优化

1. **Pipeline批量操作**: 减少网络往返
2. **连接池管理**: Lettuce连接池复用
3. **序列化优化**: Jackson2JsonRedisSerializer
4. **过期策略**: 合理设置TTL，定期清理

## 2. RabbitMQ 消息队列

### 2.1 Exchange和Queue设计

#### 订单交换机 (order.exchange)
```
Queue: order.paid.queue
Routing Key: order.paid
用途: 处理订单支付成功事件

Queue: order.canceled.queue
Routing Key: order.canceled
用途: 处理订单取消事件

Queue: order.completed.queue
Routing Key: order.completed
用途: 处理订单完成事件
```

#### 通知交换机 (notification.exchange)
```
Queue: notification.email.queue
Routing Key: notification.email
用途: 发送邮件通知

Queue: notification.system.queue
Routing Key: notification.system
用途: 发送系统消息
```

#### 推荐交换机 (recommendation.exchange)
```
Queue: recommendation.update.queue
Routing Key: recommendation.update
用途: 实时更新推荐数据
```

#### 商品交换机 (product.exchange)
```
Queue: product.created.queue
Routing Key: product.created
用途: 处理商品创建事件

Queue: product.stock.low.queue
Routing Key: product.stock.low
用途: 处理库存不足警告
```

### 2.2 事件驱动架构

#### 发布事件
```java
@Autowired
private EventPublisher eventPublisher;

// 订单支付成功
eventPublisher.publishOrderPaid(new OrderPaidEvent(
    orderId, userId, amount, paymentMethod, new Date()
));
```

#### 消费事件
```java
@RabbitListener(queues = "order.paid.queue")
public void handleOrderPaid(OrderPaidEvent event) {
    // 异步处理订单支付逻辑
    // 发送通知、更新统计、触发推荐更新等
}
```

### 2.3 可靠性保证

1. **消息持久化**: durable=true
2. **消息确认**: manual ack
3. **死信队列**: 处理失败的消息
4. **消息TTL**: 防止消息堆积
5. **重试机制**: 自动重试失败的消息

### 2.4 配置

```properties
# RabbitMQ配置
spring.rabbitmq.host=rabbitmq
spring.rabbitmq.port=5672
spring.rabbitmq.username=admin
spring.rabbitmq.password=admin123
spring.rabbitmq.virtual-host=/

# 消息确认
spring.rabbitmq.listener.simple.acknowledge-mode=auto
spring.rabbitmq.listener.simple.retry.enabled=true
spring.rabbitmq.listener.simple.retry.max-attempts=3
```

## 3. MySQL 主从复制（可扩展）

### 3.1 读写分离

```java
// 写操作 - Master
@Transactional
public void createOrder(Order order) {
    orderMapper.insert(order);
}

// 读操作 - Slave (只读副本)
@Transactional(readOnly = true)
public List<Order> getUserOrders(Integer userId) {
    return orderMapper.findByUserId(userId);
}
```

### 3.2 数据库连接池

```properties
# HikariCP连接池
spring.datasource.hikari.maximum-pool-size=20
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000
```

## 4. Elasticsearch 分布式搜索

### 4.1 应用场景

- 商品全文搜索
- 复杂条件过滤
- 聚合统计分析
- 搜索建议

### 4.2 索引设计

```json
{
  "mappings": {
    "properties": {
      "productId": { "type": "long" },
      "name": { 
        "type": "text", 
        "analyzer": "ik_max_word",
        "search_analyzer": "ik_smart"
      },
      "description": { "type": "text" },
      "category": { "type": "keyword" },
      "price": { "type": "double" },
      "location": { "type": "keyword" },
      "createdAt": { "type": "date" }
    }
  }
}
```

### 4.3 搜索优化

1. **分词优化**: IK中文分词器
2. **高亮显示**: 搜索结果高亮
3. **相关性排序**: BM25算法
4. **聚合查询**: 价格区间、分类统计

## 5. MinIO 对象存储

### 5.1 存储结构

```
Bucket: mall
├── 2025/
│   ├── 01/
│   │   ├── product_xxx.jpg
│   │   └── avatar_yyy.png
│   ├── 02/
│   └── ...
```

### 5.2 访问控制

- **Public**: 商品图片、用户头像
- **Private**: 订单凭证、私密文件

### 5.3 配置

```properties
# MinIO配置
minio.endpoint=http://minio:9000
minio.access-key=minioadmin
minio.secret-key=minioadmin
minio.bucket-name=mall
```

## 6. 分布式事务处理

### 6.1 本地事务
使用Spring @Transactional保证单库事务

### 6.2 分布式事务
采用**最终一致性**方案：

1. **事件驱动**: 通过消息队列异步处理
2. **补偿机制**: 失败后通过补偿操作回滚
3. **幂等性**: 确保重复消费不影响结果

示例：订单支付流程
```
1. 创建订单 (本地事务)
2. 发布OrderPaidEvent (消息队列)
3. 消费者处理:
   - 扣减库存
   - 发送通知
   - 更新推荐
   (每个操作独立事务 + 幂等性保证)
```

## 7. 分布式部署架构

### 7.1 Docker Compose部署

```yaml
services:
  backend:
    build: .
    ports:
      - "8080:8080"
    depends_on:
      - mysql
      - redis
      - rabbitmq
      - minio
    environment:
      - SPRING_PROFILES_ACTIVE=docker
    deploy:
      replicas: 3  # 3个实例
      
  nginx:
    image: nginx
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - backend
```

### 7.2 负载均衡

使用Nginx反向代理：
```nginx
upstream backend {
    server backend1:8080;
    server backend2:8080;
    server backend3:8080;
}

server {
    location /api/ {
        proxy_pass http://backend;
    }
}
```

## 8. 监控和运维

### 8.1 健康检查

```java
@RestController
public class HealthController {
    @GetMapping("/actuator/health")
    public Map<String, String> health() {
        return Map.of("status", "UP");
    }
}
```

### 8.2 日志聚合

使用ELK Stack:
- **Elasticsearch**: 存储日志
- **Logstash**: 收集和处理日志
- **Kibana**: 可视化查询

### 8.3 性能监控

- **Prometheus**: 收集指标
- **Grafana**: 可视化监控面板
- **Metrics**: 接口响应时间、QPS、错误率

## 9. 扩展性设计

### 9.1 水平扩展

所有服务都是无状态的，可以通过增加实例数量扩展：
```bash
docker-compose up --scale backend=5
```

### 9.2 垂直扩展

增加单个实例的资源：
```yaml
deploy:
  resources:
    limits:
      cpus: '2'
      memory: 4G
```

### 9.3 缓存策略

多级缓存：
1. **本地缓存** (Caffeine): 热点数据
2. **Redis缓存**: 共享数据
3. **数据库**: 持久化数据

## 10. 容灾和高可用

### 10.1 Redis高可用
- **Redis Sentinel**: 主从切换
- **Redis Cluster**: 分片集群

### 10.2 RabbitMQ高可用
- **镜像队列**: 多节点复制
- **联邦队列**: 跨数据中心

### 10.3 MySQL高可用
- **主从复制**: 读写分离
- **MHA**: 自动故障转移

### 10.4 备份策略
- **数据库**: 每日全量备份 + 增量备份
- **对象存储**: 跨区域复制
- **配置文件**: Git版本控制

## 性能指标

### 系统容量
- **并发用户**: 10,000+
- **QPS**: 5,000+
- **响应时间**: P95 < 500ms
- **可用性**: 99.9%

### 资源使用
- **CPU**: < 70%
- **内存**: < 80%
- **磁盘IO**: < 80%
- **网络带宽**: < 70%

## 未来优化方向

1. **微服务拆分**: 将单体应用拆分为独立的微服务
2. **服务网格**: 引入Istio进行服务治理
3. **容器编排**: 迁移到Kubernetes
4. **实时数据流**: Flink/Spark Streaming处理实时数据
5. **分布式追踪**: Zipkin/Jaeger追踪请求链路
6. **配置中心**: Nacos/Apollo动态配置管理

